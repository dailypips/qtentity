#pragma once

#include <QtEntity/EntitySystem>
#include <QHash>


namespace QtEntity
{

    template<typename T>
    class PooledEntitySystem : public EntitySystem
    {
        friend class Iterator;
    public:
        
        class Iterator : public std::iterator<std::forward_iterator_tag, T> 
        {
        public:
            Iterator(PooledEntitySystem<T>* p, size_t index) : _pool(p), _index(index) {}
            Iterator& operator=(const Iterator& other) { _pool = other._pool; _index = other._index; return *this; }
            //bool operator==(const Iterator& other) { return(_pool == other._pool && _index == other._index); }
            bool operator!=(const Iterator& other) { return(_pool != other._pool || _index != other._index); }
            T* operator*() { return static_cast<T*>(_pool->componentAt(_index)); }
            T* operator->() { return static_cast<T*>(_pool->componentAt(_index)); }
            friend bool operator==(const Iterator &lhs, const Iterator& rhs) { return (lhs._pool == rhs._pool && lhs._index == rhs._index); }
            Iterator& operator++()
            {
                ++_index;
                return *this;
            }

            Iterator operator++(int)
            {
                Iterator tmp(*this);
                ++(*this);
                return tmp;
            }
            
        private:
            PooledEntitySystem<T>* _pool;
            size_t _index;
        };


        PooledEntitySystem(size_t capacity = 0, size_t chunkSize = 4)
            : _entityManager(nullptr)
            , _capacity(capacity)
            , _chunkSize(chunkSize)
            , _size(0)            
        {
            Q_ASSERT(chunkSize > 0);
            _components = (capacity == 0) ? nullptr : operator new [](capacity * sizeof(T));                
        }

        ~PooledEntitySystem()
        {
            // call all destructors
            for(size_t i = 0; i != _size; ++i)
            {
                static_cast<T*>(componentAt(i))->~T();
            }
            operator delete[](_components);
        }

        Iterator begin() { return(Iterator(this, 0)); }
        Iterator end() { return(Iterator(this, _size)); }

        // TODO implement!
        virtual EntitySystem::Iterator pbegin() { return EntitySystem::Iterator(nullptr); }
        virtual EntitySystem::Iterator pend() { return EntitySystem::Iterator(nullptr); }

        virtual void setEntityManager(EntityManager* em) { _entityManager = em; }
        EntityManager* entityManager() const { return _entityManager; }
        virtual size_t count() const { return _size; }
        virtual QObject* componentAt(size_t at) { return &static_cast<T*>(_components)[at]; }
        virtual const QVariantMap attributesForProperty(const QString& name) const { return QVariantMap(); }
        virtual const QMetaObject& componentMetaObject() const { return T::staticMetaObject; }

        size_t size() const { return _size; }
        size_t capacity() const { return _capacity; }


        virtual QObject* getComponent(EntityId id) const
        {
            auto i = _indices.find(id);
            if(i == _indices.end()) return nullptr;
            T* ptr = static_cast<T*>(_components);
            return &ptr[i.value()];
        }


        virtual QObject* createComponent(EntityId id, const QVariantMap& properties = QVariantMap())
        {
            if(_size == _capacity) reserve(_chunkSize);
            size_t index = _size++;
            _indices[id] = index;
            T* ptr = static_cast<T*>(_components);
            T* obj = &ptr[index];
            createObjectInstance(obj, properties);
            
            if(!properties.empty())
            {
                for(int i = 0; i < componentMetaObject().propertyCount(); ++i)
                {
                    QMetaProperty prop = componentMetaObject().property(i);

                    if(!prop.isWritable())
                    {
                        qWarning() << "Trying to initialize a non-writable property. Name is: " << prop.name();
                    }
                    else
                    {
                        auto var = properties.find(prop.name());
                        if(var != properties.end())
                        {
                            bool success = prop.write(obj, var.value());
                            if(!success)
                            {
                                qWarning() << "Could not set property. Name is: " << prop.name();
                            }
                        }
                    }
                }
            }

            return obj;
        }


        virtual bool destroyComponent(EntityId id) 
        { 
            auto i = _indices.find(id);
            if(i == _indices.end()) return false;
            int indexToDestroy = i.value();         
            
            // call destructor
            T* ptr = static_cast<T*>(_components);
            ptr[indexToDestroy].~T();
            _indices.remove(id);

            // copy last entry in _components over entry to be destroyed. 
            // Don't do this if entry to be destroyed is last entry.
            if(indexToDestroy != _size - 1)
            {              
                // find index of last entry in components array.
                // Does a linear search, but probably short when starting at the end
                QtEntity::EntityId last = 0;
                size_t lastindex;
                QHashIterator<QtEntity::EntityId,size_t> j(_indices);
                j.toBack();

                while(j.hasPrevious())
                {
                    j.previous();
                    if(j.value() == _size - 1)
                    {
                        last = j.key();
                        lastindex = j.value();
                        _indices.remove(last);
                        break;
                    }
                }
                Q_ASSERT(last != 0);
                // copy last entry in _components over entry to destroy
                T* toDestroy = &ptr[indexToDestroy];
                memcpy(toDestroy, &ptr[lastindex], sizeof(T));                
                _indices[last] = indexToDestroy;
                
            }
            --_size;
            return true; 
        }


    protected:

        void reserve(int chunk)
        {
            void* components = operator new []( (_capacity + chunk) * sizeof(T) );
            if(_capacity != 0)
            {
                memcpy(components, _components, _capacity * sizeof(T));
                operator delete[](_components);
            }            
            _components = components;
            _capacity += chunk;
        }

        virtual void createObjectInstance(T* component, const QVariantMap& propertyVals)
        {
            new (component) T();
        }

        EntityManager* _entityManager;
        void* _components;        
        QHash<QtEntity::EntityId,size_t> _indices;
        size_t _size;
        size_t _chunkSize;
        size_t _capacity;
    };
}
