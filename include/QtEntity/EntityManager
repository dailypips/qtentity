#pragma once

#include <QtEntity/DataTypes>
#include <QtEntity/Export>
#include <unordered_map>
#include <QAtomicInt>
#include <QVariantMap>

namespace QtEntity
{
    class EntitySystem;
    class Component;

    /**
     * @brief The EntityManager class holds a number of entity systems in a data structure.
     * It offers methods to add and remove entity systems, also
     * convenience methods to get, add or remove components from these systems.
     * The entity manager is also responsible for creating unique entity IDs which are basically integers counting up.
     */
    class QTENTITY_EXPORT EntityManager
    {
    public:

        // data type for entity system container
        typedef std::unordered_map<ClassTypeId,EntitySystem*> EntitySystemStore;

        EntityManager();
		~EntityManager();            

        /**
         * @brief createEntityId is a thread-safe method returning
         *        integers, starting with 1 and counting up from there.
         * @return a new entity id
         */
        EntityId createEntityId();

        /**
         * @brief system returns an entity system that holds components
         *        that are of the type with given classname.
         *        Iterates through all entity systems, so has O(n/2) of number of entity systems
         * @return nullptr if not found, else the system
         */
        EntitySystem* system(const QString& classname) const;

        
        /**
         * @brief system returns an entity system that holds components
         *        that are of the type identified in ctype
         * @return nullptr if not found, else the system
         */
        EntitySystem* system(ClassTypeId ctype) const;

        /**
         * @brief Add an entity system to the entity manager.
         * The entity manager takes ownership of the system, it is
         * deleted when entity manager is deleted.
         * @throw runtime_error if entity system already in manager
         */
        void addSystem(EntitySystem* es);

        /**
         * @brief removeSystem removes entity system from manager.
         * The user takes ownership of the entity system after it is removed from entity manager.
         * @param es remove entity system of this type
         * @return false if entity system was not in manager in the first place,
         *          true if it could be removed.
         */
        bool removeSystem(EntitySystem* es);

        /**
         * @brief hasSystem returns true if an entity system of given type
         *        is present.
         * @return true if exists
         */
        bool hasSystem(ClassTypeId ctype);

        /**
         * Fetch component by component type id
         **/
        Component* component(EntityId id, ClassTypeId tid) const;

        /**
         * Templated method to get an existing component.
         * If component was not fonud then component is set to nullptr
         * Usage:
         * MyComponent* comp;
         * if(em.component(entityId, comp)) {...}
         * @param id Entity id of component to fetch
         * @param component receives pointer to component if found
         * @return true if component was found, else false
         */
        template <typename T>
        bool component(EntityId id, T*& component) const;

        /**
         * Templated method to get an existing component.
         * Usage:
         * MyComponent* comp = em.component<ComponentType>(id);
         * @param id Entity id of component to fetch
         * @return pointer to component or nullptr if component could not be fetched
         */
        template <typename T>
        T* component(EntityId id) const;

        /**
         * Fetch entity system with given ClassTypeId and create a component.
         * @param id Entity id to create component for
         * @param cid Class type id of entity system
         * @return nullptr if component could not be created, else the newly created component
         */
        Component* createComponent(EntityId id, ClassTypeId cid, const QVariantMap& properties = QVariantMap());


        /**
         * Templated method to create a new component.
         * If component already exists or can not be created then component is set to nullptr
         * and method returns false.
         *
         * Usage:
         * MyComponent* comp;
         * if(em.createComponent(entityId, comp)) {...}
         * @param id Entity id of component to create
         * @param component receives pointer to newly created component
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         * @return true if component could be created, else false
         */
        template <typename T>
        bool createComponent(EntityId id, T*& component, const QVariantMap& properties = QVariantMap());

        /**
         * Templated method to create a new component.
         * If component already exists or can not be created then it returns a nullptr.
         *
         * Usage:
         * MyComponent* comp = em.createComponent<MyComponent>(entityId)) {...}
         * @param id Entity id of component to create
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         * @return pointer to created component or nullptr if failed
         */
        template <typename T>
        T* createComponent(EntityId id, const QVariantMap& properties = QVariantMap());

        /**
         * Templated method to fetch existing component or create a new one if it is not found.
         * If component can not be created then component is set to nullptr
         * and method returns false.
         * Usage:
         * MyComponent* comp;
         * if(em.getOrCreateComponent(entityId, comp)) {...}
         * @param id Entity id of component to get or create
         * @param component receives pointer existing or to newly created component
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         *                   This is ignored if component already exists!
         * @return true if component could be found or created, else false
         */
        template <typename T>
        bool getOrCreateComponent(EntityId id, T*& component, const QVariantMap& properties = QVariantMap());

        /**
         * Destroy existing component.
         * @param id entity id of component to destroy
         * @param class type id of component to destroy
         * @return true if component existed, else false
         */
        bool destroyComponent(EntityId id, ClassTypeId cid);

        /**
         * Templated method to destroy existing component.
         * Returns true if component was found and could be destroyed, else false
         * Usage: bool success = em.destroyComponent<MyComponentType>(eid);
         * @param id Entity id of entity that component is assigned to
         * @return true if component could be destroyed, else false
         */
        template <typename T>
        bool destroyComponent(EntityId id);

        /**
         * Destroy all components registered with this entity id.
         * @param id Entity id of entity that component is assigned to
         */
        void destroyEntity(EntityId id);

        /**
         * iterators for entity systems
         */
        EntitySystemStore::iterator begin() { return _systems.begin(); }
        EntitySystemStore::iterator end() { return _systems.end(); }

        EntitySystemStore::const_iterator begin() const { return _systems.begin(); }
        EntitySystemStore::const_iterator end() const { return _systems.end(); }

    private:

        EntitySystemStore _systems;
        QAtomicInt _entityCounter;
    };


    template <typename T>
    bool EntityManager::component(EntityId id, T*& comp) const
    {
        Component* c = component(id, T::classTypeId());
        if(c == nullptr)
        {
            comp = nullptr;
            return false;
        }
        comp = static_cast<T*>(c);
        return true;
    }


    template <typename T>
    T* EntityManager::component(EntityId id) const
    {
        return static_cast<T*>(component(id, T::classTypeId()));
    }


    template <typename T>
    bool EntityManager::createComponent(EntityId id, T*& comp, const QVariantMap& properties)
    {
        Component* c = createComponent(id, T::classTypeId(), properties);
        if(c == nullptr)
        {
            comp = nullptr;
            return false;
        }
        comp = static_cast<T*>(c);
        return true;
    }


    template <typename T>
    T* EntityManager::createComponent(EntityId id, const QVariantMap& properties)
    {
        return static_cast<T*>(createComponent(id, T::classTypeId(), properties));
    }


    template <typename T>
    bool EntityManager::getOrCreateComponent(EntityId id, T*& comp, const QVariantMap& properties)
    {
        Component* c = component(id, T::classTypeId());
        if(c) {
            comp = static_cast<T*>(c);
            return true;
        }
        c = createComponent(id, T::classTypeId(), properties);
        comp = static_cast<T*>(c);
        return comp != nullptr;
    }


    template <typename T>
    bool EntityManager::destroyComponent(EntityId id)
    {
        return destroyComponent(id, T::classTypeId());
    }

}
