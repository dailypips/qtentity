#pragma once

#include <QtEntity/Export>
#include <QtEntity/EntitySystem>
#include <QHash>
#include <QDebug>

namespace QtEntity
{
    /**
     * @brief The EntityManager class holds a number of entity systems in a data structure.
     * It offers methods to add and remove entity systems, also
     * convenience methods to get, add or remove components from these systems.
     * The entity manager is also responsible for creating unique entity IDs which are basically integers counting up.
     */
    class QTENTITY_EXPORT EntityManager
    {
    public:

        // data type for entity system container
        typedef QHash<ClassTypeId,EntitySystem*> EntitySystemStore;

        EntityManager();
		~EntityManager();            

        /**
         * @brief createEntityId is a thread-safe method returning
         *        integers, starting with 1 and counting up from there.
         * @return a new entity id
         */
        EntityId createEntityId();

        /**
         * @brief system returns an entity system that holds components
         *        that are of the type with given classname.
         *        Iterates through all entity systems, so has O(n/2) of number of entity systems
         * @return nullptr if not found, else the system
         */
        EntitySystem* system(const QString& classname) const;

        
        /**
         * @brief system returns an entity system that holds components
         *        that are of the type identified in ctype
         * @return nullptr if not found, else the system
         */
        EntitySystem* system(ClassTypeId ctype) const;

        /**
         * @brief Add an entity system to the entity manager.
         * The entity manager takes ownership of the system, it is
         * deleted when entity manager is deleted.
         * @throw runtime_error if entity system already in manager
         */
        void addSystem(EntitySystem* es);

        /**
         * @brief removeSystem removes entity system from manager.
         * The user takes ownership of the entity system after it is removed from entity manager.
         * @param es remove entity system of this type
         * @return false if entity system was not in manager in the first place,
         *          true if it could be removed.
         */
        bool removeSystem(EntitySystem* es);

        /**
         * @brief hasSystem returns true if an entity system of given type
         *        is present.
         * @return true if exists
         */
        bool hasSystem(ClassTypeId ctype);

        /**
         * Templated method to get an existing component.
         * If component was not fonud then component is set to nullptr
         * Usage:
         * MyComponent* comp;
         * if(em.component(entityId, comp)) {...}
         * @param id Entity id of component to fetch
         * @param component receives pointer to component if found
         * @return true if component was found, else false
         */
        template <typename T>
        bool component(EntityId id, T*& component) const;

        /**
         * Templated method to get an existing component.
         * Usage:
         * MyComponent* comp = em.component<ComponentType>(id);
         * @param id Entity id of component to fetch
         * @return pointer to component or nullptr if component could not be fetched
         */
        template <typename T>
        T* component(EntityId id) const;

        /**
         * Templated method to create a new component.
         * If component already exists or can not be created then component is set to nullptr
         * and method returns false.
         *
         * Usage:
         * MyComponent* comp;
         * if(em.createComponent(entityId, comp)) {...}
         * @param id Entity id of component to create
         * @param component receives pointer to newly created component
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         * @return true if component could be created, else false
         */
        template <typename T>
        bool createComponent(EntityId id, T*& component, const QVariantMap& properties = QVariantMap());

        /**
         * Templated method to create a new component.
         * If component already exists or can not be created then it returns a nullptr.
         *
         * Usage:
         * MyComponent* comp = em.createComponent<MyComponent>(entityId)) {...}
         * @param id Entity id of component to create
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         * @return pointer to created component or nullptr if failed
         */
        template <typename T>
        T* createComponent(EntityId id, const QVariantMap& properties = QVariantMap());

        /**
         * Templated method to fetch existing component or create a new one if it is not found.
         * If component can not be created then component is set to nullptr
         * and method returns false.
         * Usage:
         * MyComponent* comp;
         * if(em.getOrCreateComponent(entityId, comp)) {...}
         * @param id Entity id of component to get or create
         * @param component receives pointer existing or to newly created component
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         *                   This is ignored if component already exists!
         * @return true if component could be found or created, else false
         */
        template <typename T>
        bool getOrCreateComponent(EntityId id, T*& component, const QVariantMap& properties = QVariantMap());

        /**
         * Templated method to destroy existing component.
         * Returns true if component was found and could be destroyed, else false
         * Usage: bool success = em.destroyComponent<MyComponentType>(eid);
         * @param id Entity id of entity that component is assigned to
         * @return true if component could be destroyed, else false
         */
        template <typename T>
        bool destroyComponent(EntityId id);

        /**
         * Destroy all components registered with this entity id.
         * @param id Entity id of entity that component is assigned to
         */
        void destroyEntity(EntityId id);

        /**
         * iterators for entity systems
         */
        EntitySystemStore::iterator begin() { return _systems.begin(); }
        EntitySystemStore::iterator end() { return _systems.end(); }

        EntitySystemStore::const_iterator begin() const { return _systems.begin(); }
        EntitySystemStore::const_iterator end() const { return _systems.end(); }

    private:

        QHash<ClassTypeId,EntitySystem*> _systems;
        QAtomicInt _entityCounter;
    };

    template <typename T>
    bool EntityManager::component(EntityId id, T*& component) const
    {
        EntitySystem* s = this->system(T::classTypeId());
        Component* c;
        if(s == nullptr || nullptr == (c = s->component(id)))
        {
            component = nullptr;
            return false;
        }
        component = static_cast<T*>(c);
        return true;
    }


    template <typename T>
    T* EntityManager::component(EntityId id) const
    {
        EntitySystem* s = this->system(T::classTypeId());
        Component* c;
        if(s == nullptr || nullptr == (c = s->component(id)))
        {
            return nullptr;
        }
        return static_cast<T*>(c);
    }


    template <typename T>
    bool EntityManager::createComponent(EntityId id, T*& component, const QVariantMap& properties)
    {
        EntitySystem* s = this->system(T::classTypeId());

        if(s == nullptr || s->component(id) != nullptr)
        {
            return false;
        }
        try
        {
            component = static_cast<T*>(s->createComponent(id, properties));
            return component != nullptr;
        }
        catch(std::bad_alloc&)
        {
            qCritical() << "Could not create component, bad allocation!";
            return false;
        }

    }


    template <typename T>
    T* EntityManager::createComponent(EntityId id, const QVariantMap& properties)
    {
        T* ret;
        createComponent(id, ret, properties);
        return ret;
    }


    template <typename T>
    bool EntityManager::getOrCreateComponent(EntityId id, T*& component, const QVariantMap& properties)
    {
        EntitySystem* s = this->system(T::classTypeId());

        if(s == nullptr) return false;
        component = static_cast<T*>(s->component(id));

        if(component != nullptr) return true;

        component = static_cast<T*>(s->createComponent(id, properties));
        return (component != nullptr);
    }


    template <typename T>
    bool EntityManager::destroyComponent(EntityId id)
    {
        EntitySystem* s = this->system(T::classTypeId());
        if(s == nullptr) return false;
        return s->destroyComponent(id);
    }

}
