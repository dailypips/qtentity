#pragma once

#include <QtEntity/DataTypes>
#include <QObject>
#include <QVariantMap>
#include <QDebug>
#include <functional>
#include <QtEntity/MetaObjectRegistry>

namespace QtEntity
{
    class Component
    {
    public:
        virtual ~Component() {}
        virtual QtEntity::ClassTypeId typeId() const = 0;
    };

#define NOEXP
#define DECLARE_COMPONENT_TYPE(EXPMACRO)\
    public:\
        EXPMACRO static QtEntity::ClassTypeId classTypeId();\
        EXPMACRO virtual QtEntity::ClassTypeId typeId() const override;\
    private:\
        EXPMACRO static QtEntity::Component* createComponent();\
        static QtEntity::ClassTypeId _typeId;


#define IMPLEMENT_COMPONENT_TYPE(TYPE)\
    QtEntity::ClassTypeId TYPE::_typeId = QtEntity::ComponentRegistry::registerComponent(#TYPE, &TYPE::createComponent);\
    QtEntity::Component* TYPE::createComponent(void) { return new TYPE(); }\
    QtEntity::ClassTypeId TYPE::classTypeId(void) { return TYPE::_typeId; }\
    QtEntity::ClassTypeId TYPE::typeId(void) const { return _typeId; }


#define QTE_ADD_PROPERTY(NAME, VARIANTTYPE, COMPONENTTYPE, GETTER, SETTER) \
    {    auto getter = [this](QtEntity::EntityId id) {\
            auto c = static_cast<COMPONENTTYPE*>(component(id)); return(c) ? QVariant::fromValue(c->GETTER()) : QVariant();\
        };\
        auto setter = [this](QtEntity::EntityId id, const QVariant& v) {\
            auto c = static_cast<COMPONENTTYPE*>(component(id)); if(!c) qDebug() << "Cannot write property " << NAME << ", component not found with id " << id; else c->SETTER(v.value<VARIANTTYPE>());\
        };\
        addProperty(QtEntity::PropertyAccessor(NAME, qMetaTypeId<VARIANTTYPE>(), getter, setter));\
    }

#define QTE_ADD_PROPERTY_WITH_ATTRIBS(NAME, VARIANTTYPE, COMPONENTTYPE, GETTER, SETTER, ATTRIBS) \
    {    auto getter = [this](QtEntity::EntityId id) {\
            auto c = static_cast<COMPONENTTYPE*>(component(id)); return(c) ? QVariant::fromValue(c->GETTER()) : QVariant();\
        };\
        auto setter = [this](QtEntity::EntityId id, const QVariant& v) {\
            auto c = static_cast<COMPONENTTYPE*>(component(id)); if(!c) qDebug() << "Cannot write property " << NAME << ", component not found with id " << id; else c->SETTER(v.value<VARIANTTYPE>());\
        };\
        addProperty(QtEntity::PropertyAccessor(NAME, qMetaTypeId<VARIANTTYPE>(), getter, setter, ATTRIBS));\
    }

    class PropertyAccessor
    {
    public:
        typedef std::function<QVariant(EntityId)> Getter;
        typedef std::function<void(EntityId, const QVariant&)> Setter;

        PropertyAccessor()
            : _name("")
            , _variantType(0)
            , _getter(nullptr)
            , _setter(nullptr)
        {
        }

        PropertyAccessor(const QString& name, int variantType, Getter getter, Setter setter, const QVariantMap& attributes = QVariantMap())
            : _name(name)
            , _variantType(variantType)
            , _getter(getter)
            , _setter(setter)
            , _attributes(attributes)
        {
        }

        QString name() const { return _name; }
        QVariant read(EntityId id) { Q_ASSERT(_getter); return _getter(id); }
        bool write(EntityId id, const QVariant& val) { if(!_setter) return false; _setter(id, val); return true; }
        const QVariantMap& attributes() const { return _attributes; }
        bool valid() const { return _getter != nullptr && _setter != nullptr; }

        // return QVariant type
        int variantType() const { return _variantType; }
    private:
        QString _name;
        int _variantType;
        Getter _getter;
        Setter _setter;
        QVariantMap _attributes;
    };

    // fwd declaration
    class EntityManager;

    /**
     * An interface class for defining entity systems.
     * Entity systems are responsible for storing and managing components.
     * Each entity system instance holds components of a specific type.
     */
    class EntitySystem : public QObject
    {
    public:

        virtual ~EntitySystem() {}

        /**
         * @brief component Return component associated with passed id
         * @param id EntityId of component to fetch
         * @return component or nullptr if it does not exist
         */
        virtual Component* component(EntityId id) const = 0;

        /**
         * @brief createComponent Construct a component from meta type.
         * @throw runtime_exception
         *
         * @param id Entity id to associate it with
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         * @return newly constructed component
         */
        virtual Component* createComponent(EntityId id, const QVariantMap& properties = QVariantMap()) = 0;

        /**
         * @brief destroyComponent remove component from system and destruct it
         *
         * @param id Entity id of component to destruct
         * @return true if component existed, else false
         */
        virtual bool destroyComponent(EntityId id) = 0;

        /**
         * @return type of component class
         */
        virtual ClassTypeId componentType() const = 0;

        QString componentName() const { return ComponentRegistry::className(componentType()); }

        /**
         * @return number of components
         */
        virtual size_t count() const = 0;

        // TODO remove
        virtual const QVariantMap attributesForProperty(const QString& name) const = 0;
        //////////////////////////////////////
        int propertyCount() const { return _properties.size(); }
        PropertyAccessor property(int idx) { return _properties.at(idx); }
        const PropertyAccessor property(int idx) const { return _properties.at(idx); }

    protected:
        void addProperty(const PropertyAccessor& a) { _properties.push_back(a); }
    private:
        QVector<PropertyAccessor> _properties;
    public:
        //////////////////////////////////////

        /**
         * This is called by entity manager when system is added to entity manager
         */
        virtual void setEntityManager(EntityManager* em) = 0;

        class Iterator;

        /**
         * pend() and pbegin() implementations have to return EntitySystem::Iterator instances.
         * These are polymorphic iterators which can be used to iterate over all components
         * without having to know the component type.
         * Using these is slower than using the type specific begin() and end() iterators
         * and should only be used if specific type information is not present.
         * Example implementation:
         *    return EntitySystem::Iterator(new VIteratorImpl<std::vector<MyComponent>::Iterator>(begin()));
         * where std::vector<MyComponent> is the type of the container holding the components.
        */
        virtual Iterator pbegin() = 0;
        virtual Iterator pend() = 0;

        /**
         * Abstract iterator interface for implementing forward iterators.
         * Used in EntitySystem::Iterator for wrapping other iterators in a polymorphic interface.
         */
        class VIterator
        {
        public:
            virtual ~VIterator() {}
            virtual VIterator* clone() = 0;            
            virtual Component* object() = 0;
            virtual bool equal(VIterator* other) = 0;
            virtual void increment() = 0;
        };

        /**
         * Convenience template for implementing VIterator interface with a concrete Iterator class.
         * U is the type of the concrete iterator.
         */
        template <typename U>
        class VIteratorImpl : public VIterator
        {
            U _iter;
        public:
            VIteratorImpl(const U& it) :_iter(it) {}
            virtual VIterator* clone() { return new VIteratorImpl<U>(_iter); }
            virtual Component* object() { return *_iter; }
            virtual bool equal(VIterator* other) { return _iter == static_cast<VIteratorImpl<U>*>(other)->_iter; }
            virtual void increment() { ++_iter; }
        };

        /**
         * @brief The Iterator class for iterating through all components of an EntitySystem.
         * Uses a VIterator heap object for accessing the concrete underlying iterator.
         */
        class Iterator : public std::iterator<std::forward_iterator_tag, Component*> 
        {
        public:
            Iterator(VIterator* vit) : _viter(vit) {}
            Iterator(const Iterator& other) : _viter(other._viter->clone()) {}
            ~Iterator() { delete _viter; }
            Iterator operator=(const Iterator& other) { delete _viter; _viter = other._viter->clone(); return *this;  }
            bool operator!=(const Iterator& other) { return !(_viter->equal(other._viter)); }
            Component* operator*() { return _viter->object(); }
            Component* operator->() { return _viter->object(); }
            friend bool operator==(const Iterator &lhs, const Iterator& rhs) { return lhs._viter->equal(rhs._viter); }
            Iterator& operator++()
            {
                _viter->increment();
                return *this;
            }

            Iterator operator++(int)
            {
                Iterator tmp(*this);
                ++(*this);
                return tmp;
            }

        private:
            
            VIterator* _viter;
        };
        
    };

    inline QVariantMap propertyValues(EntitySystem* es, EntityId eid)
    {
        QVariantMap m;
        for(int i = 0; i < es->propertyCount(); ++i)
        {
            auto prop = es->property(i);
            m[prop.name()] = prop.read(eid);
        }
        return m;
    }

    inline QVariantMap propertyAttributes(EntitySystem* es)
    {
        QVariantMap m;
        for(int i = 0; i < es->propertyCount(); ++i)
        {
            auto prop = es->property(i);
            m[prop.name()] = prop.attributes();
        }
        return m;
    }

    inline void applyPropertyValues(EntitySystem* es, EntityId eid, const QVariantMap& m)
    {
        for(int i = 0; i < es->propertyCount(); ++i)
        {
            auto prop = es->property(i);
            if(m.contains(prop.name())) 
            {
                bool success = prop.write(eid, m[prop.name()]);
                if(!success)
                {
                    qWarning() << "Could not set property. Name is: " << prop.name();
                }
            }
        }
    }
}
