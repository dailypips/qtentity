#pragma once

#include <QtEntity/DataTypes>
#include <QObject>
#include <QVariantMap>

namespace QtEntity
{
    // fwd declaration
    class EntityManager;

    class EntitySystem : public QObject
    {
    public:

        virtual ~EntitySystem() {}

        /**
         * This is called by entity manager when system is added to entity manager
         */
        virtual void setEntityManager(EntityManager* em) = 0;

        /**
         * @brief getComponent Return component associated with passed id
         * @param id EntityId of component to fetch
         * @return component or nullptr if it does not exist
         */
        virtual QObject* getComponent(EntityId id) const = 0;

        /**
         * @brief createComponent Construct a component from meta type.
         * @throw runtime_exception
         *
         * @param id Entity id to associate it with
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         * @return newly constructed component
         */
        virtual QObject* createComponent(EntityId id, const QVariantMap& properties = QVariantMap()) = 0;

        /**
         * @brief destroyComponent remove component from system and destruct it
         *
         * @param id Entity id of component to destruct
         * @return true if component existed, else false
         */
        virtual bool destroyComponent(EntityId id) = 0;

        /**
         * @return  meta object type of component class
         */
        virtual const QMetaObject& componentMetaObject() const = 0;

        /**
         * @brief Returns all additional attributes for a property.
         * This can be overwritten by entity system implementations to return
         * a map of QVariants. This is especially used for specifying constraints
         * for the QtPropertyBrowser, but can be used for other means.
         * @param name Name of the property
         * @return a map of QVariants
         */
        virtual const QVariantMap attributesForProperty(const QString& name) const = 0;

        /**
         * Return number of components
         */
        virtual size_t count() const = 0;

        class Iterator;

        /** polymorphic iterators.
         * Using these is slower 
        */
        virtual Iterator pbegin() = 0;
        virtual Iterator pend() = 0;


        class VIterator
        {
        public:
            virtual ~VIterator() {}
            virtual VIterator* clone() = 0;            
            virtual QObject* object() = 0;
            virtual bool equal(VIterator* other) = 0;
            virtual void increment() = 0;
        };

        template <typename U>
        class VIteratorImpl : public VIterator
        {
            U _iter;
        public:
            VIteratorImpl(const U& it) :_iter(it) {}
            virtual VIterator* clone() { return new VIteratorImpl<U>(_iter); }
            virtual QObject* object() { return *_iter; }
            virtual bool equal(VIterator* other) { return _iter == static_cast<VIteratorImpl<U>*>(other)->_iter; }
            virtual void increment() { ++_iter; }
        };


        class Iterator : public std::iterator<std::forward_iterator_tag, QObject*> 
        {
        public:
            Iterator(VIterator* vit) : _viter(vit) {}
            Iterator(const Iterator& other) : _viter(other._viter->clone()) {}
            ~Iterator() { delete _viter; }
            Iterator operator=(const Iterator& other) { delete _viter; _viter = other._viter->clone(); return *this;  }
            bool operator!=(const Iterator& other) { return !(_viter->equal(other._viter)); }
            QObject* operator*() { return _viter->object(); }
            QObject* operator->() { return _viter->object(); }
            friend bool operator==(const Iterator &lhs, const Iterator& rhs) { return lhs._viter->equal(rhs._viter); }
            Iterator& operator++()
            {
                _viter->increment();
                return *this;
            }

            Iterator operator++(int)
            {
                Iterator tmp(*this);
                ++(*this);
                return tmp;
            }
            
        private:
            
            VIterator* _viter;
        };

        
    };

}
