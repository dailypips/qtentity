#pragma once

#include <QtEntity/Export>
#include <QtEntity/EntitySystem>
#include <unordered_map>
#include <stdexcept>

namespace QtEntity
{

    /**
     * A basic implementation of an EntitySystem.
     * Components are created with new() and stored in a HashMap.
     */
    template <typename T>
    class SimpleEntitySystem : public EntitySystem
    {
        
    public:
        // data type of storage
        typedef std::unordered_map<EntityId, T*> ComponentStore;
        typedef typename ComponentStore::iterator iterator;
        /**
         * @brief EntitySystem constructor.
         * @param componentMeta the QMetaObject of the Component subclass that
         *                      this entity system uses as components
         */
        SimpleEntitySystem() {}

        virtual ~SimpleEntitySystem()
	    {
            for(auto i = _components.begin(); i != _components.end(); ++i)
            {
                delete i->second;
            }
            _components.clear();
        }

        /**
         * This is called by entity manager when system is added to entity manager
         */
        virtual void setEntityManager(EntityManager* em) override
        {
            _entityManager = em;
        }

        /**
         * @brief fetch entityManager this system is associated with
         */
        EntityManager* entityManager() const
        {
            return _entityManager;
        }

        /**
         * @brief component Return component associated with passed id
         * @param id EntityId of component to fetch
         * @return component or nullptr if it does not exist
         */
        virtual Component* component(EntityId id) const override
        {
            auto i = _components.find(id);
            return (i == _components.end()) ? nullptr : i->second;
        }

        bool component(EntityId id, T*& component) const
        {
            Component* obj = this->component(id);
            component = static_cast<T*>(obj);
            return (component != NULL);
        }

        /**
         * @brief createComponent Construct a component from meta type.
         * @throw runtime_exception
         *
         * If you override this method then please make sure that you emit componentCreated() when
         * a component was created
         *
         * @param id Entity id to associate it with
         * @param properties A map of property values to apply to component before adding it to system
         *                   Format is: { name of QMetaProperty => value to set }
         * @return newly constructed component
         */
        virtual Component* createComponent(EntityId id, const QVariantMap& properties = QVariantMap()) override
        {
            // check if component already exists
            if(component(id) != nullptr)
            {
                throw std::runtime_error("Component already existss!");
            }

            // use QMetaObject to construct new instance
            T* component = new T();
            // out of memory?
            if(component == nullptr)
            {
                qCritical() << "Could not construct component. Have you registered the component type?";
                throw std::runtime_error("Component could not be constructed.");
            }

            // store
            _components[id] = component;
            applyPropertyValues(this, id, properties);
            return component;       
        }

        /**
         * @brief destroyComponent remove component from system and destruct it
         * If you override this method then please make sure that you emit componentAboutToDestruct() before
         * a component is destroyed
         *
         * @param id Entity id of component to destruc
         * @return true if component existed, else false
         */
        virtual bool destroyComponent(EntityId id) override
        {        
            auto i = _components.find(id);
            if(i == _components.end()) return false;
            delete i->second;
            _components.erase(i);
            return true;
        }

        /**
         * @return type id of component class
         */
        virtual ClassTypeId componentType() const { return T::classTypeId(); }

        /**
         * Return begin iterator of component container
         */
        typename ComponentStore::iterator begin() { return _components.begin(); }

        /**
         * Return end iterator of component container
         */
        typename ComponentStore::iterator end() { return _components.end(); }

        /**
         * Delete component and return iterator pointing to next component
         */
        typename ComponentStore::iterator erase(typename ComponentStore::iterator& i)
        {
            typename ComponentStore::iterator next = i; ++next;
            destroyComponent(i->first);
            return next;
        }

        /**
         * Return begin iterator of component container
         */
        typename ComponentStore::const_iterator begin() const { return _components.begin(); }

        /**
         * Return end iterator of component container
         */
        typename ComponentStore::const_iterator end() const { return _components.end(); }

       
        virtual EntitySystem::PIterator pbegin() override
        {
            return EntitySystem::PIterator(new VIteratorImpl<typename ComponentStore::iterator>(begin()));
        }

        virtual EntitySystem::PIterator pend() override
        {
            return EntitySystem::PIterator(new VIteratorImpl<typename ComponentStore::iterator>(end()));
        }

        virtual void clear()
        {
            _components.clear();
        }

        /**
         * @brief Returns all additional attributes for a property.
         * This can be overwritten by entity system implementations to return
         * a map of QVariants. This is especially used for specifying constraints
         * for the QtPropertyBrowser, but can be used for other means.
         * @param name Name of the property
         * @return a map of QVariants
         */
        virtual const QVariantMap attributesForProperty(const QString& name) const override { return QVariantMap(); }

        /**
         * Return number of components
         */
        virtual size_t count() const override
        {
            return _components.size();
        }

    protected:
       
        /**
         * The entity manager that this entity system is assigned to.
         * Is NULL if entity system was never added
         */
        EntityManager* _entityManager;

        ComponentStore _components;
    };
    
}
